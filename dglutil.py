from darmonpoints.util import our_nroot
from sage.rings.all import NumberField
from sage.rings.infinity import Infinity


def act_flt(gamma, tau):
    if isinstance(tau, list):
        return [act_flt(gamma, t) for t in tau]
    a, b, c, d = gamma.list()
    # K = tau.parent()
    if tau == 0:
        return b / d if d else Infinity
    elif tau == Infinity:
        return a / c if c else Infinity
    else:
        return (a * tau + b) / (c * tau + d)


def recognize_DGL_algdep(J, degree, toleratce=0.9, roots_of_unity=None, outfile=None):
    K = J.parent()
    p = K.prime()
    if roots_of_unity is None:
        roots_of_unity = our_nroot(K(1), lcm(12, (p**2 - 1)), return_all=True)
    height_threshold = tolerance * J.precision_relative()
    Jzlist0 = [(J * zz, i) for i, zz in enumerate(roots_of_unity)]
    Jzlist = []
    for Jz, i in Jzlist0:
        Jzlist.append((Jz, i, 1))
        try:
            Jzlist.append((our_nroot(Jz, 2), i, 2))
            Jzlist.append((our_nroot(Jz, 4), i, 4))
        except ValueError:
            continue
    for Jz, i, pw in sorted(Jzlist, key=lambda v: v[2], reverse=True):
        ff = our_algdep(Jz, degree)
        x = ff.parent().gen()
        height_poly = height_polynomial(ff, base=p)
        if height_poly < height_threshold:
            ff = ff.factor()[-1][0]
            nrm = QQ(ff.constant_coefficient()) / ff.leading_coefficient()
            real_tol = height_poly / J.precision_relative()
            clist_ans = [("J", pw)]
            Hz = NumberField(ff, names="z")
            zfac = Hz.ideal(Hz.gen()).factor()
            Jfac = [(o.norm().radical(), e) for o, e in zfac]
            clist_ans.extend(Jfac)
            fwrite("# SUCCESS! (tol = %s)" % (real_tol), outfile)
            fwrite(
                f"# {ff.factor()} (Norm = {nrm.factor()})\t (J * exp(2 pi i {i} / {lcm(12,(p**2-1))}))^(1/{pw})\t{str(clist_ans)} (height={height_poly})",
                outfile,
            )
            try:
                ffsmall = sage_eval(str(pari("polredabs(%s)" % ff)), locals={"x": x})
            except PariError:
                ffsmall = ff
            fwrite(
                "Number field generated by J has primitive polynomial = %s" % ffsmall,
                outfile,
            )
            return Jz, ff, ffsmall, nrm, 1, i, lcm(12, (p**2 - 1)), clist_ans
    return None, None, None


def recognize_DGL_lindep(J, L, prime_list, Cp=None, units=None, outfile=None, **kwargs):
    r""" """
    recurse_subfields = kwargs.pop("recurse_subfields", False)
    degree_bound = kwargs.pop("degree_bound", Infinity)
    print(f"Doing DGL-lindep with {L = }")
    if recurse_subfields:
        kwargs["phi"] = None
        ans = None
        for L0, _, _ in L.subfields():
            if L0.degree() <= degree_bound:
                try:
                    new_ans = recognize_DGL_lindep(
                        J, L0, prime_list, Cp=Cp, units=units, outfile=outfile, **kwargs
                    )
                    if new_ans is not None and ans is None:
                        ans = new_ans
                except ValueError:
                    pass
                if new_ans is not None:
                    print(new_ans)
                    return ans
        return ans
    K = J.parent()
    p = K.prime()
    Jval = J.valuation()
    assert K(p).valuation() == 1
    J *= p**-Jval
    prec = J.precision_relative()
    # embed L in a field containing K
    if Cp is None:
        Cp = K
        K_to_Cp = K.hom([K.gen()])
    else:
        K_to_Cp = K.hom([polynomial_roots(K._exact_modulus(), Cp)[0]])
    embeddings = polynomial_roots(L.polynomial(), Cp)
    if len(embeddings) == 0:
        raise ValueError(f"L (={L}) does not embed into Cp (={Cp})")
    phi_list = kwargs.get("phi_list", None)
    if phi_list is None:
        phi_list = [L.hom([rt]) for rt in embeddings]

    max_size = kwargs.get('max_size', Infinity)
    for phi in phi_list:
        V = [None]
        Vlogs = [K_to_Cp(J.log(0))]
        W = ["J"]
        hL = 1
        glist = []
        size = 0
        for ell in prime_list:
            for pp, _ in L.ideal(ell).factor():
                verbose(f"(Factoring {ell}")
                hL0 = 0
                gens = [None, None]
                while len(gens) > 1:
                    hL0 += hL
                    gens = (pp**hL0).gens_reduced(proof=False)
                hL = hL0
                glist.append((gens[0], hL, ell))
            size += L.degree() * RR(ell).log()
            if size > max_size:
                break
        glist = [
            (g ** ZZ(hL / e), ell) for g, e, ell in glist if phi(g).valuation() == 0
        ]
        norm_one = kwargs.get("norm_one", J.norm() == 1)
        while len(glist) > 0:
            g0, ell = glist[0]
            phiv = phi(g0)
            if norm_one:
                g1 = next(
                    (
                        o
                        for o, ellp in glist[1:]
                        if ellp == ell and (phiv / phi(o)).norm().log() == 0
                    ),
                    1,
                )
            else:
                g1 = 1
            V.append(g0 / g1)
            Vlogs.append((phiv / phi(g1)).log(0))
            W.append(ell)
            glist = [(o, ell) for o, ell in glist if o != g0 and o != g1]

        # Add units
        if units is None:
            units = list(L.units(proof=False))
        else:
            units = [L(o) for o in units]
        for i, u in enumerate(units):
            V.append(u)
            Vlogs.append(phi(u).log(0))
            W.append(f"u{i}")

        # Truncate precision if prec is specified
        prec = kwargs.get("prec", prec)
        if prec is not None:
            Vlogs = [o.add_bigoh(prec) for o in Vlogs]

        # OK now cross fingers...
        clist = kwargs.get("clist", None)
        if clist is not None:
            assert len(clist) == len(
                Vlogs
            ), f"Provided clist is of incorrect length (should be {len(Vlogs)})"
            return sum([c * o for c, o in zip(clist, Vlogs)])
        verbose(f"Running lindep with {len(Vlogs) = }")
        if kwargs.get("debug_Vlogs", None) is not None:
            return Vlogs
        clist = our_lindep(Vlogs, **kwargs)
        if clist[0] < 0:
            clist = [-o for o in clist]
        verbose(f"clist = {clist}")
        verbose(f"W = {W}")
        verbose(f"Should be zero : {sum([c * o for c, o in zip(clist, Vlogs)])}")
        if clist[0] == 0:
            verbose(f"Not recognized: clist[0] = {clist[0]}")
            return None
        ht = 2 * sum((1 + RR(o).abs()).log(p) for o in clist)
        verbose(f"(confidence factor: { ht / prec})")
        if ht > prec:
            verbose(
                f"Not recognized (confidence factor: ht / prec = {ht / prec}): clist = {clist}"
            )
            return None
        clist_ans = [(u, v) for u, v in zip(W, clist) if v != 0]
        fwrite("# SUCCESS!", outfile)
        fwrite(f"# {clist_ans}", outfile)
        algebraic = kwargs.get("algebraic", True)
        if not algebraic:
            return clist_ans
        else:
            verbose(str(clist_ans))
            if not clist[0] > 0:
                verbose(f"Redundant set of primes?")
                return None
            assert len(V) == len(clist)
            J_alg = prod(u**-a for u, a in zip(V[1:], clist[1:]))
            remainder = clist[0]
            phiJalg = phi(J_alg)
            Jp = K_to_Cp(J)
            Jpr = Jp**remainder
            try:
                check = (phiJalg / Jpr).log(0).valuation() >= 0.75 * prec
                if not check:
                    print("Did not pass check! Returning value anyway...")
            except ValueError as e:
                print("Did not pass check because it errored! (error = %s)" % str(e))

            # Adjust root of unity
            n = len(Cp.residue_field()) - 1
            R = ZZ["t, x"]
            t, x = R.gens()
            x0 = ZZ["x"].gen()
            jlist = J_alg.minpoly().list()
            d = lcm([o.denominator() for o in jlist])
            jlist = [ZZ(d * o) for o in jlist]
            jpol = sum(o * t**i for i, o in enumerate(jlist))
            found = False
            for i, zeta in enumerate(Cp.roots_of_unity()):
                if (phiJalg - (zeta * Jpr)).valuation() >= 0.75 * prec:
                    d = ZZ(n / ZZ(n).gcd(i))
                    found = True
                    break
            if not found:
                d = 0
            adjust_root_of_unity = kwargs.get("adjust_root_of_unity", False)
            if adjust_root_of_unity:
                found = False
                phi = cyclotomic_polynomial(d)
                dg = phi.degree()
                phi = sum(o * t**i * x ** (dg - i) for i, o in enumerate(phi.list()))
                ff0 = phi.resultant(jpol)
                ff0 = ZZ["x"](ff0)
                for ff, _ in ff0.factor():
                    if ff(Jpr).valuation() >= 0.75 * prec:
                        found = True
                        break
                if not found:
                    print("Could not find the actual polynomial")
                ff = ff(x0 / p**Jval)
            else:
                ff = J_alg.minpoly()
            ffsmall = ff
            try:
                ffsmall = sage_eval(
                    str(pari("polredabs(%s)" % ffsmall)), locals={"x": QQ["x"].gen()}
                )
            except PariError:
                pass
            return (
                ff,
                remainder,
                d,
                clist_ans,
                ffsmall,
            )  # DEBUG - didn't check that they match...
