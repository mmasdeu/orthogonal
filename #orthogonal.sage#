# from tqdm import tqdm
from sage.rings.padics.precision_error import PrecisionError
from multiprocessing import Process, Manager, Pool, cpu_count
from concurrent import futures
from sage.misc.timing import cputime
from util import *

def get_predicted_field_and_prime_list(F, D, n, typ, char, names='z', prime_bound=600):
    r'''
    If smallRM:
    - If char == triv: return F
    - If char == conj: return HCF of Q(sqrt(-D))

    If smallCM:
    - If char == triv: return HCF of Q(sqrt(-D))
    - If char == conj: return Q
    '''
    if typ in ['smallRM','smallCM'] and n != 1:
        return None, None
    if char not in ['triv', 'conj']:
        raise ValueError('Parameter "char" must be either "triv" or "conj"')
    x = QQ['x'].gen()
    if typ == 'smallCM':
        D = -D
    if typ == 'bigRM':
        alpha = ATR_alpha(D,n)
        L0 = alpha.parent()
        L = tau_ATR_field(alpha)
    else:
        L.<a> = QuadraticField(D)
        M = (L.composite_fields(F, names='t0')[0]).absolute_field(names='t1')
    if typ == 'smallCM' and char == 'conj':
        H = QQ
    else:
        try:
            H = (L.hilbert_class_field(names='tt').composite_fields(F)[0]).absolute_field(names=names)
        except AttributeError:
            H = NumberField(magma(L).HilbertClassField().AbsoluteField().DefiningPolynomial()._sage_(),names='tt').composite_fields(F)[0].absolute_field(names=names)
    prime_list = [p for p in prime_range(prime_bound) if len(L.ideal(p).factor()) < L.degree()]
    if typ != 'bigRM':
        assert all(len(M.ideal(p).factor()) < M.degree() for p in prime_list)
    return H, prime_list

# Related to Manin Trick
def quo_rem_in_gaussian_integers(a,b):
    if b == 0:
        raise ZeroDivisionError
    K = a.parent()
    q = ((a/b)[0]).round('away') + ((a/b)[1]).round('away')*K.gen()
    r = a - q*b
    assert r.norm() < b.norm()
    return (q, r)

def xgcd_in_gaussian_integers(a, b):
    v1 = vector([1,0])
    v2 = vector([0,1])
    if b == 0:
        return (a, v1[0], v1[1])
    if a == 0:
        return (b, v2[0], v2[1])
    a0 = a
    b0 = b
    q, r = quo_rem_in_gaussian_integers(a0,b0)
    while True:
        d = a0 - q*b0
        if d == 0:
            assert b0 == v2[0]*a + v2[1]*b
            return (b0, v2[0], v2[1])
        v3 = v1 - q* v2
        v1 = vector([v2[0], v2[1]])
        v2 = vector([v3[0], v3[1]])
        a0 = b0
        b0 = d
        q, r = quo_rem_in_gaussian_integers(a0,b0)
    return

# computes the continued fraction of a/c, where a and c belong to Z[i]
def continued_fraction(a, c):
    a_over_c = a/c
    cf = []
    while c != 0:
        q, r = quo_rem_in_gaussian_integers(a,c)
        cf.append(q)
        a = c
        c = r
    assert a_over_c == eval_cf(cf)
    return cf

# given a continued fraction, computes its value as an element of Q(i); only for debugging
def eval_cf(cf):
    if len(cf) == 1:
        return cf[0]
    if len(cf) == 2:
        return cf[0] + 1/cf[1]
    new_cf = [cf[i+1] for i in range(len(cf)-1)]
    return eval_cf([cf[0],eval_cf(new_cf)])

# computes the convergents of a continued fraction, following Hardy-Wright theorem 149
def compute_convergents(cf):
    N = len(cf)
    if N == 1:
        return([[cf[0]], [1]])
    p = [cf[0], cf[1] * cf[0] +1]
    q = [1, cf[1]]
    for n in range(2, N):
        p.append(cf[n] * p[n-1] + p[n-2])
        q.append(cf[n] * q[n-1] + q[n-2])
    assert all([p[n]*q[n-1] - p[n-1]*q[n] == (-1)^(n-1) for n in range(1,N)])
    #assert p[-1]/q[-1] == eval_cf(cf)
    return(p, q)

# given the convergents [p_i] and [q_j] of a continued fraction for alpha, computes the matrices that Mi such that {Infinity, alpha} = {M0(0), M0(Infinity)} + {M1(0), M1(Infinity)} + ... as in display (2.1.8) of Cremona's book
def compute_Ms(p, q):
    Ms = []
    Ms.append(Matrix(2,2,[-p[0], 1, -q[0], 0])) # j = 0
    for j in range(1, len(p)):
        Ms.append(Matrix(2,2,[(-1)^(j-1)*p[j],p[j-1],(-1)^(j-1)*q[j],q[j-1]]))
    assert all([A.det() == 1 for A in Ms])
    return Ms

# given a, c in Z[i] returns the matrices that Mi such that {Infinity, a/c} = {M0(0), M0(Infinity)} + {M1(0), M1(Infinity)} + ... as in display (2.1.8) of Cremona's book
def matrices_for_unimodular_path(a,c):
    cf = continued_fraction(a, c)
    p, q = compute_convergents(cf)
    return compute_Ms(p, q)


# checking
def act_mobius(a,b,c,d,tau):
    return act_matrix(matrix([[a,b],[c,d]]), tau)

def act_matrix(gamma, tau):
    if isinstance(tau, list):
        return [act_matrix(gamma, t) for t in tau]
    a, b, c, d = gamma.list()
    K = tau.parent()
    if tau == 0:
        return K(b / d) if d else Infinity
    elif tau == Infinity:
        return K(a / c) if c else Infinity
    else:
        return (K(a)*tau + K(b)) / (K(c)*tau + K(d))

### Define functions
def all_elements_of_norm(F, n):
    if n == 0:
        return [F(0)]
    else:
        eps = F.unit_group().gens()[0]
        units = [F(eps**i) for i in range(eps.multiplicative_order())]
        return [u * beta for beta in F.elements_of_norm(n) for u in units]

def vectors_in_lattice(p, n):
    resp = []
    resm = []
    for mac in range(1,n+1):
        RHS = n - mac
        betas = all_elements_of_norm(F, RHS)
        for mc in divisors(mac):
            a = mac // mc
            condition = a % p == 0 and mc % p == 0
            for beta in betas:
                if condition and (beta / p).is_integral():
                    continue
                else:
                    new_mat = Matrix([[beta.conjugate(), mc], [a, -beta]])
                    if a % 4 == 1:
                        resp.append(new_mat)
                    elif a % 4 == 3:
                        resm.append(-new_mat)
    return resp, resm

def inv(FF):
    global Rp
    a0inv = ~Rp(FF(0)(0))
    y1 = 0
    y = a0inv
    while y != y1:
        y1 = y
        y = y1 * (2 - y1 * FF)
    return y


@parallel(ncpus=cpu_count())
def compute_level1_contribution(A, Ap, sgn, Rp):
    Rpol = PolynomialRing(F,2,names='u,v')
    t1, t2 = Rpol.gens()
    pol = vector(Rpol, [-1,t1]) * A * vector(Rpol, [t2,1])
    polp = pol.change_ring(phi).change_ring(GF(p))
    R1 = PolynomialRing(GF(p),names='x')
    x = R1.gen()
    to_x = pol.parent().hom([x,x], codomain=R1,check=False)
    d1, d2 = polp.degrees()
    if d1 == 0 and d2 == 0:
        j1, j2, tau1, tau2 = p, p, t1, t2
    if d1 == 1 and d2 == 0:
        j1, j2 = polp.change_ring(to_x).roots()[0][0].lift(), p
        tau1, tau2 = j1 + 1 / t1, t2
    if d1 == 0 and d2 == 1:
        j1, j2 = p, polp.change_ring(to_x).roots()[0][0].lift()
        tau1, tau2 = t1, j2 + 1 / t2
    if d1 == 1 and d2 == 1:
        ff = polp.factor()
        assert len(ff) == 2,'Does not factor'
        f1 = ff[1][0]
        f2 = ff[0][0]
        assert f1.degrees() == (1,0) and f2.degrees() == (0,1)
        j1 = f1.change_ring(to_x).roots()[0][0].lift()
        j2 = f2.change_ring(to_x).roots()[0][0].lift()
        tau1, tau2 = j1 + 1 / t1, j2 + 1 / t2
    ans = (pol.parent()(pol(tau1,tau2) * t1**d1 * t2**d2)).change_ring(phi)
    while j1 < 0:
        j1 += p
    while j2 < 0:
        j2 += p
    ans = ans.change_ring(Rp)
    ans = map_poly(ans)
    return j1, j2, ans, sgn

def Level1(V, M):
    global ncpus
    try:
        ncpus = ncpus
    except NameError:
        ncpus = cpu_count()
    res = {(i,j) : [Ruv(1), Ruv(1)] for i in range(p+1) for j in range(p+1)}
    dg = {(i,j) : 0 for i in range(p+1) for j in range(p+1)}
    input_vec = []
    for (A, B) in zip(*V):
        Ap = A.apply_map(lambda x : Rp(phi(x).lift()))
        Bp = B.apply_map(lambda x : Rp(phi(x).lift()))
        input_vec.extend([(A,Ap,1,Rp), (B,Bp,-1,Rp)])
    for A, Ap, sgn, _ in input_vec:
        i, j, FF, sgn = compute_level1_contribution(A, Ap, sgn, Rp)
        if sgn == 1:
            res[i,j][0] *= FF
        else:
            res[i,j][1] *= FF
        dg[i,j] += sgn
    with futures.ProcessPoolExecutor(max_workers=ncpus) as executor:
        # Calculate inverses
        print('Calculating inverses...')
        future = {executor.submit(inv, val[1]) : ky for ky, val in res.items()}
        for fut in futures.as_completed(future):
            ky = future[fut]
            val = fut.result()
            res[ky] = res[ky][0] * val
    return res, dg

@cached_function
def ApplySingle(A, i, z, M, check=True):
    a, b, c, d = A.change_ring(ZZ).list()
    if check:
        assert A.determinant().valuation() == 0, "Error in embeddings?"
    if i == p:
        u = GF(p)(a)
        v = GF(p)(c)
    else:
        u = GF(p)(a*i+b)
        v = GF(p)(c*i+d)
    if not check and (u == 0 and v == 0):
        return 1, None
    ii = p if v == 0 else (u / v).lift()
    assert 0 <= ii <= p
    if i == p:
        if ii == p:
            r = Rp(c/a) * z
            substx = ~Rp(a) * (d*z - b)
        else:
            r = Rp((-c*ii + a)/c) * z
            substx = -~Rp(c) * (d + (d*ii-b)*z)
    else:
        if ii == p:
            r = Rp((c*i+d)/(a*i+b)) * z
            substx = -Rp(~(a*i+b)) * (a-c*z)
        else:
            r = Rp(-(ii - (a*i+b)/(c*i+d))) * z
            substx = Rp(~(c*i+d)) * (-c + (a-c*ii)*z)
    if r != 0:
        substx *= sum(r**k for k in range(M+1))
    return ii, substx


def Transform(outky):
    global gF, input_list
    res = Ruv(1)
    resinv = Ruv(1)
    t1 = 0
    t2 = 0
    for inky, s1, s2, sgn in input_list[outky]:
        f = gF[inky]
        t = cputime()
        newres = sum(sum(aij * s1[j] for aij, j in zip(fi.coefficients(), fi.exponents())) * s2[i] for fi, i in zip(f.coefficients(), f.exponents()))
        # a00inv = ~Rp(newres(0)(0)) # Normalize
        # newres *= a00inv
        t1 += cputime(t)
        t = cputime()
        if sgn == 1:
            res *= newres
        else:
            resinv *= newres
        t2 += cputime(t)
    t = cputime()
    ans = res * inv(resinv)
    t3 = cputime(t)
    return ans, (t1,t2,t3)

def Next(F, timing=False):
    global gF, ncpus
    try:
        ncpus = ncpus
    except NameError:
        ncpus = cpu_count()
    gF = F
    res = {(i,j) : 1 for i in range(p+1) for j in range(p+1)}
    t1 = 0
    t2 = 0
    t3 = 0
    if parallelize:
        with futures.ProcessPoolExecutor(max_workers=ncpus) as executor:
            # Iteration
            future_dict = {executor.submit(Transform, outky) : outky for outky, inps in input_list.items()}
            for fut in futures.as_completed(future_dict):
                outky = future_dict[fut]
                ans, (t1p, t2p, t3p) = fut.result()
                t1 += t1p
                t2 += t2p
                t3 += t3p
                res[outky] = ans
    else:
        for outky, inps in input_list.items():
            res[outky] = Transform(outky)[0]
    if timing:
        return res, (t1, t2, t3)
    else:
        return res

def mul_dict(x,y):
    return {ky : x[ky] * y[ky] for ky in x}

def degrees(res):
    dumax = max(ff.degree() for ff in res.values())
    dvmax = max(o.degree() for ff in res.values() for o in ff.coefficients())
    return dumax, dvmax

def RMC(F, M):
    global ncpus
    try:
        ncpus = ncpus
    except NameError:
        ncpus = cpu_count()
    FF = F
    res = [F]
    d = (-1,-1)
    j = 0
    while d != (0,0):
        j += 1
    # for j in range(1,M):
        print(f'Iteration {j}')
        t = walltime()
        FF0, (t1, t2, t3) = Next(FF,timing=True)
        FF, (tt1, tt2, tt3) = Next(FF0,timing=True)
        t1 += tt1
        t2 += tt2
        t3 += tt3
        res.append(FF)
        d = degrees(FF)
        print(f'..done in {walltime(t)} seconds. {t1 = :.2f}, {t2 = :.2f}, {t3 = :.2f}. Degrees: {d}')
    print(f'Now computing product...')
    t = walltime()
    if parallelize:
        with futures.ProcessPoolExecutor(max_workers=ncpus) as executor:
            while len(res) > 1:
                future_dict = {executor.submit(mul_dict, res[i], res[i+1]) : i for i in range(0,len(res)-1, 2) }
                res = [] if len(res) % 2 == 0 else [res[-1]]
                for fut in futures.as_completed(future_dict):
                    res.append(fut.result())
        ans = res[0]
    else:
        ans = {ky : prod(r[ky] for r in res) for ky in res[0] }
    print(f'..done in {walltime(t)} seconds.')
    R0 = Ruv.base_ring()
    psi = R0.hom([ZZ['u'].gen()],base_map=lambda x:x.lift(),check=False)
    ans = {ky : f.change_ring(psi) for ky, f in ans.items()}
    return ans

def RMC_noprod(F, M):
    FF = F
    res = [F]
    for j in range(1,M):
        print(f'Iteration {j}')
        t = walltime()
        FF0, (t1, t2, t3) = Next(FF,timing=True)
        FF, (tt1, tt2, tt3) = Next(FF0,timing=True)
        t1 += tt1
        t2 += tt2
        t3 += tt3
        res.append(FF)
        d = degrees(FF)
        print(f'..done in {walltime(t)} seconds. {t1 = :.2f}, {t2 = :.2f}, {t3 = :.2f}. Degrees: {d}')
    return res

def fixed_point(g, phi):
    a, b, c, d = g.list()
    K = g.parent()
    Kp = phi.codomain()
    x = Kp['x'].gen()
    f = phi(c)*x**2 + phi(d-a)*x - phi(b)
    p = Kp.prime()
    L = Qq(p**2, Kp.precision_cap(),names='b')
    return solve_quadratic(f.change_ring(phi).change_ring(L), L, return_all=True)

def Eval0(L0, tau):
    t0, t1 = tau
    vv = vector([-1, t0])
    ww = vector([t1, 1])
    KK = vv.parent().base_ring()
    ans = prod((vv * num.apply_morphism(phi).apply_map(lambda o : KK(o)) * ww) / (vv * den.apply_morphism(phi).apply_map(lambda o : KK(o)) * ww) for num, den in zip(*L0))
    return ans

def EvalPS(f, x0, x1, prec):
    ans = 1
    x0s = [1, x0]
    x1s = [1, x1]
    for _ in range(prec):
        x0s.append(x0 * x0s[-1])
        x1s.append(x1 * x1s[-1])
    return sum(sum(o * x0s[j] for o, j in zip(a.coefficients(), a.exponents()) if j < prec) * x1s[i] for a, i in zip(f.coefficients(), f.exponents()) if i < prec)

def Eval(tau, prec):
    global J
    t0, t1 = tau
    ans = 1
    for ky in J:
        x0 = t0 if ky[0] == p else 1/(t0 - ky[0])
        x1 = t1 if ky[1] == p else 1/(t1 - ky[1])
        ans *= EvalPS(J[ky], x0, x1, prec)
    return ans


def good_matrices(m):
    a, b, c, d = m.list()
    F = m.parent().base_ring()
    r = F.gen()
    I = F.ideal(2)
    if F == QQ or F == ZZ:
        raise NotImplementedError
    if c in I:
        return [ (m,-1) ]
    elif d in I:
        m = matrix([[b, a], [d, c]])
        return [ (m, 1) ]
    else:
        for d1, d2 in cartesian_product_iterator([[1,-1,r,-r] for _ in range(2)]):
            delta = -(m.determinant())
            A, B, C, D = m.list()
            y = matrix([[-C, d1], [D, d2]]).determinant()/delta
            if y in I:
                x = matrix([[d1, A], [d2, -B]]).determinant()/delta
                m1 = matrix([[A,x],[C,y]])
                m2 = matrix([[x,B],[y,D]])
                m1.rescale_col(1, -d1**-1)
                m2.rescale_col(0, d2**-1)
                m1.swap_columns(0,1)
                assert m1.determinant() == 1
                assert m2.determinant() == 1
                return [(m1,1),(m2,-1)]
    raise RuntimeError(f'No good matrix found for m = {m.list()}!')

def smallCMcycle(D):
    A = compute_gamma_tau(D).change_ring(F)
    t0, t1 = fixed_point(A, phi)
    hE = QuadraticField(-D,'w').class_number()
    return A, [t0, t1], hE

def smallRMcycle(D):
    A = compute_gamma_tau(D).change_ring(F)
    t0, t1 = fixed_point(A, phi)
    hE = QuadraticField(D,'w').class_number()
    return A, [t0, t0], hE # not a typo!

def bigRMcycle(D, n=1):
    alpha = ATR_alpha(D, n)
    A, tau0, tau1 = compute_gamma_tau_ATR(alpha)
    E = tau_ATR_field(alpha)
    return A, [tau0, tau1], E.class_number()

def RMCEval(D, cycle_type, prec, n=1, return_class_number=False):
    global L0, J, ncpus
    try:
        ncpus = ncpus
    except NameError:
        ncpus = cpu_count()
    if cycle_type == 'smallCM':
        A, tau0, hE = smallCMcycle(D)
    elif cycle_type == 'smallRM':
        A, tau0, hE = smallRMcycle(D)
    else:
        if cycle_type != 'bigRM':
            raise NotImplementedError('Cycle type should be either "smallCM" or "smallRM" or "bigRM"')
        A, tau0, hE = bigRMcycle(D, n)

    if any(t.trace() == 2 * t for t in tau0):
        raise ValueError(f'Tuple {(D,n) = } is not admissible for {cycle_type} cycle: the resulting tau is not in Hp.')
    mlist0 = matrices_for_unimodular_path(A[0,0], A[1,0])
    mlist = sum((good_matrices(m) for m in mlist0),[])
    res0 = prod(Eval0(L0, act_matrix(m.apply_morphism(phi).adjugate(), tau0))**sgn for m,sgn in mlist)
    if parallelize:
        res1 = 1
        with futures.ProcessPoolExecutor(max_workers=ncpus) as executor:
            future_dict = {executor.submit(Eval, act_matrix(m.apply_morphism(phi).adjugate(), tau0), prec) : sgn for m, sgn in mlist}
            for fut in futures.as_completed(future_dict):
                res1 *= fut.result()**(future_dict[fut])
    else:
        res1 = prod(Eval(act_matrix(m.apply_morphism(phi).adjugate(), tau0), prec)**sgn for m,sgn in mlist)
    ans = res0 * res1
    ans = ans.add_bigoh(prec + ans.valuation())
    if return_class_number:
        return ans, hE
    else:
        return ans

def list_powers(x, M):
    if x is None:
        return x
    plist = [x.parent()(1)]
    for i in range(M):
        plist.append(x * plist[-1])
    return plist

def change_sign_in_matrices(ms):
    return [(m, -s) for m, s in ms]

def random_candidate_matrices(r, limit=-1):
    found_matrices = 0
    yield matrix(2,2,1)
    FF = r.parent()
    i = 0
    while i != limit:
        i += 1
        a = FF.random_element()
        co2 = FF.random_element()
        c = 2*co2
        x,d,b = xgcd_in_gaussian_integers(a, c)
        if not x in [1, -1, r, -r]:
            continue
        d = d/x
        b = b/x
        m = matrix(2,2,[a,-b,c,d])
        yield m
        assert m.det() == 1
        m2 = matrix(2,2,[r*a, -b, c, -r*d])
        assert m2.det() == 1
        yield m2
    raise StopIteration

def calculate_Tp_matrices(P, M):
    global input_list
    r = P.parent().gens()[0]
    Tplist = [matrix(2,2,[P, a, 0, 1]) for a in range(P.norm()) ] + [matrix(2,2,[1,0,0,P])]
    MS = []
    r = P.parent().gen()
    i = -1
    for m0 in Tplist:
        i += 1
        found = False
        for c in random_candidate_matrices(r, limit=10**5):
            try:
                m = m0 * c
                # print('c = ',c.list())
                mlist0 = matrices_for_unimodular_path(-m[0,1], m[0,0])
                mlist = sum((good_matrices(o) for o in mlist0),[])
                if m[1,0] != 0:
                    mlist1 = matrices_for_unimodular_path(-m[1,1], m[1,0])
                    mlist_to_add = sum((change_sign_in_matrices(good_matrices(o)) for o in mlist1),[])
                    mlist = mlist + mlist_to_add
                if not all((m * o).apply_map(lambda x : x.trace() - x).apply_morphism(phi).determinant().valuation() == 0 for o,sgn in mlist):
                    raise RuntimeError('Problem with embedding, try the other one.')
                MS.extend((m * o, sgn) for o, sgn in mlist)
                found = True
                break
            except RuntimeError:
                continue
        if found == False:
            raise RuntimeError('still cannot find good matrix')
    apply_single_dict = {}
    S = Ruv
    R = S.base_ring()
    z1 = R.gen()
    z2 = S.gen()
    for cnt, (m, sgn) in enumerate(MS):
        update_progress(float(cnt)/len(MS))
        m.set_immutable()
        mconj = m.apply_map(lambda x : x.trace() - x)
        A = m.apply_morphism(phi)
        Aconj = mconj.apply_morphism(phi)
        for i in range(p+1):
            ii, subst1 = ApplySingle(A, i, z1, M, check=False)
            jj, subst2 = ApplySingle(Aconj, i, z2, M, check=True)
            apply_single_dict[m,i,0] = (ii, list_powers(subst1,M))
            apply_single_dict[m,i,1] = (jj, list_powers(subst2,M))

    input_list = {(i,j) : list() for i in range(p+1) for j in range(p+1)}
    for m, sgn in MS:
        for inky0 in range(p+1):
            outky0, s1 = apply_single_dict[(m, inky0, 0)]
            if s1 is None:
                continue
            for inky1 in range(p+1):
                inky = (inky0, inky1)
                outky1, s2 = apply_single_dict[(m, inky1, 1)]
                if s2 is None:
                    continue
                outky = (outky0, outky1)
                input_list[outky].append((inky, s1, s2, sgn))
    return

def calculate_Tp_matrices_old(P, M):
    global input_list
    Tplist = [matrix(2,2,[P, a, 0, 1]) for a in range(P.norm()) ] + [matrix(2,2,[1,0,0,P])]
    MS = []
    for m in Tplist:
        assert m[1,0] == 0
        mlist0 = matrices_for_unimodular_path(-m[0,1], m[0,0])
        mlist = sum((good_matrices(o) for o in mlist0),[])
        if not all((m * o).apply_map(lambda x : x.trace() - x).apply_morphism(phi).determinant().valuation() == 0 for o,sgn in mlist):
            raise RuntimeError('Problem with embedding, try the other one.')

        MS.extend((m * o, sgn) for o, sgn in mlist)
    apply_single_dict = {}
    S = Ruv
    R = S.base_ring()
    z1 = R.gen()
    z2 = S.gen()
    for cnt, (m, sgn) in enumerate(MS):
        update_progress(float(cnt)/len(MS))
        m.set_immutable()
        mconj = m.apply_map(lambda x : x.trace() - x)
        A = m.apply_morphism(phi)
        Aconj = mconj.apply_morphism(phi)
        for i in range(p+1):
            ii, subst1 = ApplySingle(A, i, z1, M, check=False)
            jj, subst2 = ApplySingle(Aconj, i, z2, M, check=True)
            apply_single_dict[m,i,0] = (ii, list_powers(subst1,M))
            apply_single_dict[m,i,1] = (jj, list_powers(subst2,M))

    input_list = {(i,j) : list() for i in range(p+1) for j in range(p+1)}
    for m, sgn in MS:
        for inky0 in range(p+1):
            outky0, s1 = apply_single_dict[(m, inky0, 0)]
            if s1 is None:
                continue
            for inky1 in range(p+1):
                inky = (inky0, inky1)
                outky1, s2 = apply_single_dict[(m, inky1, 1)]
                if s2 is None:
                    continue
                outky = (outky0, outky1)
                input_list[outky].append((inky, s1, s2, sgn))
    return


# given a non-necessary fundamental discriminant D, computes the matrix gamma_tau associated to an optimal embedding of the ring of discriminant D to M_0(2)
def compute_gamma_tau(D):
    Dsqf = ZZ(D).squarefree_part()
    try:
        c = ZZ((ZZ(D) / fundamental_discriminant(D)).sqrt())
    except TypeError:
        raise ValueError('D is not the discrimininant of a quadratic order')
    F.<r> = QuadraticField(Dsqf)
    w = F.maximal_order().ring_generators()[0]
    # O_c has Z-basis <1, cw>, we use this basis to embed O_c into M_2(Z)
    coords = (c*w).coordinates_in_terms_of_powers()
    D0 = Matrix([[0,1], coords((c*w)^2)]).transpose() # the image of cw in M_2(Z)
    aa, bb, cc, dd = D0.list()
    # if D0 is not in M_0(2), we conjugate the embedding to force this condition
    A = Matrix(2,2,[0,1,-1,0])
    B = Matrix(2,2,[2,1,1,1])
    if cc % 2 == 0:
        D1 = D0
    elif bb % 2 == 0:
        D1 = A * D0 * A.inverse()
    elif (aa - dd) % 2 == 0:
        D1 = B * D0 * B.inverse()
    else:
        raise RuntimeError('It seems that there is no optimal embedding of O_c into Gamma_0(2)')
    assert D1.minpoly() == (c*w).minpoly()
    assert D1[1][0] % 2 == 0
    # now we find the fundamental unit of O_c
    eps = F.units()[0]
    if eps.norm() == -1:
        eps = eps**2 # DEBUG: is this really needed?
    n = 1
    while True:
        u = eps**n
        cs = coords(u)
        if all([o.is_integer() for o in cs]):
            gamma_tau = cs[0] + cs[1] * D1
            assert gamma_tau.minpoly() == u.minpoly()
            assert gamma_tau[1][0] % 2 == 0
            return gamma_tau
        n +=1


def ATR_alpha(D, n=1):
    try:
        return QuadraticField(D, names='t').elements_of_norm(-1)[0] * n
    except IndexError:
        raise ValueError(f'Discriminant (={D}) not admissible: no elements of norm -1 in QQ(sqrt(D))')


def tau_ATR_field(alpha, names='w'):
    FF = alpha.parent()
    y = FF['y'].gen()
    return NumberField(y*y - alpha, names=names)

# it accepts a real quadratic field FF and an element alpha in FF of norm -1; then E = FF(sqrt(alpha) is the ATR extension and K = Q(i) is contained in the galois closure of E
def compute_gamma_tau_ATR(alpha):
    # FF = alpha.parent()
    # x = QQ['x'].gen()
    # R.<y> = PolynomialRing(FF)
    E = tau_ATR_field(alpha,'w')
    w = E.gen()
    K = F
    MM.<gMM> = E.galois_closure()
    if MM.disc() % p == 0:
        raise NotImplementedError('tau lives in a ramified extension') # p ramifies in MM so we would need to work with ramified extensions
    # Now we redefine E, because we want to view it as a subfield of MM. We also construct L as a subfield of MM
    EEp = [f for f in MM.subfields() if f[0].degree() == 4 and f[0].is_isomorphic(E)]
    LLp = [f for f in MM.subfields() if f[0].degree() == 4 and not f[0].is_isomorphic(E)]
    E, sigmaE, _ = EEp[0]
    L, sigmaL, _ = LLp[1]

    # take the unit of norm 1 in E
    sigma = E.automorphisms()[1]
    found = False
    for uu in E.units():
        if uu.absolute_minpoly().degree() == 4 and uu*sigma(uu) == 1:
            u = uu
            found = True
    if found == False:
        raise RuntimeError('did not find a unit of relative norm one')
    # from u construct gamma and its galois conjugate gamma_p
    gL = L.primitive_element()
    Gal_M_L = [t for t in MM.automorphisms() if t(sigmaL(gL)) == sigmaL(gL)]
    gE = E.primitive_element()
    Gal_M_E = [t for t in MM.automorphisms() if t(sigmaE(gE)) == sigmaE(gE)]
    Nu = Gal_M_L[1](sigmaE(u)) * sigmaE(u) # compute N_{M/L}(u)
    L_K.<gL_K> = L.relativize(K.embeddings(L)[0])
    u_L_K = Nu.minpoly().roots(L_K)[0][0] # this is Nu viewed as an element of the relative extension L_K
    a, c = u_L_K.vector()
    b, d = (u_L_K * gL_K).vector()
    gamma = Matrix(2,2,[a,b,c,d])
    # this matrix is constructed using the K-basis <1, gL_K>, but gL_K is not a generator of the ring of integers of L/K, so we need to change basis
    _, gOLK = module_generators(L_K) # gOLK is a generator of O_L_K over O_K
    O = L_K.maximal_order()
    X = Matrix([(1,0), gOLK.vector()]).transpose() # change of basis matrix
    # we check that gOLK is a generator of O_L_K over O_K, by checking that any generator of O_L_K when written in terms of <1, gOLK> has integral coefficients
    for gen in O.gens():
        if not all([o.is_integral() for o in (X.inverse()* vector(gen.vector())).list() ]):
            raise RuntimeError('it seems that we do not have an embedding of the maximal order')
    # now we conjugate gamma to express it in terms of the basis <1, gOLK>
    gamma = X^-1 * gamma * X
    Ms = [Matrix(2,2,[1,0,0,1]), Matrix(2,2,[0,1,-1,0]), Matrix(2,2,[2,1,1,1]), Matrix(2,2,[1+i,1,i,1]), Matrix(2,2,[1+i,1,1,1]), Matrix(2,2,[i,1,0,1]), Matrix(2,2,[i,1,2*i,1])]
    found = False
    for mm in Ms:
        aa, bb, cc, dd = (mm * gamma * ~mm).list()
        if cc.real() % 2 == 0 and cc.imag() % 2== 0:
            found = True
            gamma = mm * gamma * ~mm
            break
    if not found:
        raise RuntimeError('maybe there is no embedding into Gamma0(2)?')
    gamma_p = gamma.apply_morphism(a.parent().automorphisms()[1])
    assert u_L_K.minpoly() == gamma.minpoly()

    # Now we compute the matrix M and the scalar l such that gamma * M * gamma_p^{-1} = l * M
    A.<xx,yy,bb,cc,ll> = PolynomialRing(K)
    alpha = xx + i*yy
    alpha_p = xx-i*yy
    M = Matrix(A,2,2,[alpha, -bb,cc,-alpha_p])
    B.<x,y,b,c,l> = PolynomialRing(E)
    fAB = A.hom([x,y,b,c,l], B, check = False)
    s = K.automorphisms()[1]
    Meq = gamma*M - ll*M*gamma_p
    eqns =[fAB(M.det())] +  [fAB((z + z.map_coefficients(s))/2) for z in Meq.list()] + [fAB((z - z.map_coefficients(s))/(2*i)) for z in Meq.list()]  + [c-1]
    I = B.ideal(eqns)
    pt = I.variety()[0]
    alpha = sigmaE(pt[x]) + K.embeddings(MM)[0](i) * sigmaE(pt[y])
    alpha_p = sigmaE(pt[x]) - K.embeddings(MM)[0](i) * sigmaE(pt[y])
    M = Matrix(MM, 2, 2, [alpha, -sigmaE(pt[b]), sigmaE(pt[c]), -alpha_p])
    Mp = Matrix(MM, 2, 2, [alpha_p, -sigmaE(pt[b]), sigmaE(pt[c]), -alpha])
    iKM = K.embeddings(MM)[0]
    # assert that M is fiexed under the action of gamma
    assert gamma.apply_map(iKM) * M * gamma_p.apply_map(iKM)**-1 == sigmaE(pt[l]) * M
    tau1 = M[0][0]
    tau2 = -M[1][1]
    # Now we compute the imge of tau1 and tau2 in Qp**2
    Kp = phi.codomain()
    L = Qq(p**2, Kp.precision_cap(),names='b')
    roots = [a[0] for a in MM.defining_polynomial().roots(L)]
    if len(roots) == 0:
        raise RuntimeError('tau does not live in Qp**2')
    # we find an embedding of MM into Qp**2 that extends phi
    found_emb = False
    for r in roots:
        iMML = MM.hom([r],L)
        if iMML(iKM(K.gen())) == L(phi(K.gen())):
            found_emb = True
            break
    if found_emb == False:
        raise RuntimeError('No embedding of MM into Qp**2 found that extends phi')
    return gamma, iMML(tau1), iMML(tau2)




def functional_old(p, N = 20):
    # We only consider d with are not a norm from Z[i]
    valid_ds = [i for i in range(1, N) if not sum_of_squares(i)]

    MM = []
    MFs = ModularForms(4*p).cuspidal_subspace().gens()
    for g0 in MFs:
        g = list(g0.q_expansion(N+1))
        l = lcm([QQ(o).denominator() for o in g])
        MM.append([l * o for o in g])
    E = lambda n : sum([ o for o in ZZ(n).divisors() if o % 4 != 0])
    A = Matrix([[E(o) for o in valid_ds]] + [[ZZ(g[o]) for o in valid_ds] for g in MM])
    # vectors in the kernel correspond to functionals that vanish on g and on the Eisenstein series
    # the first position of the vector in the kernel corresponds to a_1, and so on
    L = IntegralLattice(ZZ(len(valid_ds))).sublattice(A.right_kernel().basis())
    length_cap = 8
    all_vectors = sum(L.short_vectors(length_cap),[])
    ans = []
    ans_expanded = []
    W = L.submodule(ans)
    i = 0
    while W.rank() < L.rank():
        print(W.rank(),L.rank())
        try:
            while L.submodule(ans + [all_vectors[i]]).rank() == W.rank():
                i += 1
        except IndexError:
            length_cap *= 1.5
            length_cap = ZZ(length_cap.ceil())
            all_vectors = sum(L.short_vectors(length_cap),[])
        try:
            v = all_vectors[i]
        except IndexError:
            continue
        print(f'Adding {v = }')
        ans.append(v)
        vexp = [0 for _ in range(1,N)]
        for val, idx in zip(v, valid_ds):
            vexp[idx-1] = val
        ans_expanded.append(vexp)
        W = L.submodule(ans)
    return ans_expanded


def initial_seed(v, p):
    if isinstance(v, str):
        v = functional_from_label(v)
    v = tuple(v)
    L0 = [[], []]
    V = [[], []]
    for i, vi in enumerate(v, start=1):
        if vi == 0:
            continue
        Li = vectors_in_lattice(p, i)
        print(len(Li[0]), len(Li[1]))
        Vi = vectors_in_lattice(p, p * i)
        if vi > 0:
            L0[0].extend(vi * Li[0])
            L0[1].extend(vi * Li[1])
            V[0].extend(vi * Vi[0])
            V[1].extend(vi * Vi[1])
        elif vi < 0:
            L0[1].extend((-vi) * Li[0])
            L0[0].extend((-vi) * Li[1])
            V[1].extend((-vi) * Vi[0])
            V[0].extend((-vi) * Vi[1])
    assert len(L0[0]) == len(L0[1])
    assert len(V[0]) == len(V[1])
    return L0, V


def find_value_one(maxD, cycle_type='smallCM'):
    stats = {'0':[], '1':[], 'oo':[], '?':[], 'err':[]}
    for D in srange(2, maxD):
        print(D)
        if D.is_square():
            continue
        try:
            c2 = ZZ(D / fundamental_discriminant(D))
            c2 = c2.sqrt()
        except TypeError:
            continue
        try:
            x1 = RMCEval(D,cycle_type=cycle_type,prec=10)
            if x1 == 1:
                print(f'{D = } yields one')
                stats['1'].append(D)
            elif x1 == 0:
                print(f'{D = } yields zero')
                stats['0'].append(D)
            elif x1.valuation() < 40:
                print(f'{D = } yields infinity')
                stats['oo'].append(D)
            else:
                print(f'{D = } yields {x1}')
                stats['?'].append(D)
        except (TypeError, ValueError, RuntimeError) as e:
            stats['err'].append((D,str(e)))
        except PrecisionError:
            stats['oo'].append(D)
    return stats

